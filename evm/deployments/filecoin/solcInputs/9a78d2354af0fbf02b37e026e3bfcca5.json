{
  "language": "Solidity",
  "sources": {
    "@oasisprotocol/sapphire-contracts/contracts/Sapphire.sol": {
      "content": "// SPDX-License-Identifier: Apache-2.0\npragma solidity ^0.8.8;\n\n/**\n * @title Sapphire\n * @dev Convenient wrapper methods for Sapphire's cryptographic primitives.\n */\nlibrary Sapphire {\n    address private constant RANDOM_BYTES =\n        0x0100000000000000000000000000000000000001;\n    address private constant DERIVE_KEY =\n        0x0100000000000000000000000000000000000002;\n    address private constant ENCRYPT =\n        0x0100000000000000000000000000000000000003;\n    address private constant DECRYPT =\n        0x0100000000000000000000000000000000000004;\n    address private constant GENERAGE_SIGNING_KEYPAIR =\n        0x0100000000000000000000000000000000000005;\n    address private constant SIGN_DIGEST =\n        0x0100000000000000000000000000000000000006;\n    address private constant VERIFY_DIGEST =\n        0x0100000000000000000000000000000000000007;\n    address private constant CURVE25519_PUBLIC_KEY =\n        0x0100000000000000000000000000000000000008;\n\n    type Curve25519PublicKey is bytes32;\n    type Curve25519SecretKey is bytes32;\n\n    enum SigningAlg {\n        // Ed25519 signature over the provided message using SHA-512/265 with a domain separator.\n        // Can be used to sign transactions for the Oasis consensus layer and SDK paratimes.\n        Ed25519Oasis,\n        // Ed25519 signature over the provided message.\n        Ed25519Pure,\n        // Ed25519 signature over the provided prehashed SHA-512 digest.\n        Ed25519PrehashedSha512,\n        // Secp256k1 signature over the provided message using SHA-512/256 with a domain separator.\n        // Can be used to sign transactions for the Oasis consensus layer and SDK paratimes.\n        Secp256k1Oasis,\n        // Secp256k1 over the provided Keccak256 digest.\n        // Can be used to sign transactions for Ethereum-compatible networks.\n        Secp256k1PrehashedKeccak256,\n        // Secp256k1 signature over the provided SHA-256 digest.\n        Secp256k1PrehashedSha256,\n        // Sr25519 signature over the provided message.\n        Sr25519\n    }\n\n    /**\n     * @dev Returns cryptographically secure random bytes.\n     * @param numBytes The number of bytes to return.\n     * @param pers An optional personalization string to increase domain separation.\n     * @return The random bytes. If the number of bytes requested is too large (over 1024), a smaller amount (1024) will be returned.\n     */\n    function randomBytes(uint256 numBytes, bytes memory pers)\n        internal\n        view\n        returns (bytes memory)\n    {\n        (bool success, bytes memory entropy) = RANDOM_BYTES.staticcall(\n            abi.encode(numBytes, pers)\n        );\n        require(success, \"randomBytes: failed\");\n        return entropy;\n    }\n\n    /**\n     * @dev Generates a Curve25519 keypair.\n     * @param pers An optional personalization string used to add domain separation.\n     * @return pk The Curve25519 public key. Useful for key exchange.\n     * @return sk The Curve25519 secret key. Pairs well with {`deriveSymmetricKey`}.\n     */\n    function generateCurve25519KeyPair(bytes memory pers)\n        internal\n        view\n        returns (Curve25519PublicKey pk, Curve25519SecretKey sk)\n    {\n        bytes memory scalar = randomBytes(32, pers);\n        // Twiddle some bits, as per RFC 7748 ยง5.\n        scalar[0] &= 0xf8; // Make it a multiple of 8 to avoid small subgroup attacks.\n        scalar[31] &= 0x7f; // Clamp to < 2^255 - 19\n        scalar[31] |= 0x40; // Clamp to >= 2^254\n        (bool success, bytes memory pkBytes) = CURVE25519_PUBLIC_KEY.staticcall(\n            scalar\n        );\n        require(success, \"gen curve25519 pk: failed\");\n        return (\n            Curve25519PublicKey.wrap(bytes32(pkBytes)),\n            Curve25519SecretKey.wrap(bytes32(scalar))\n        );\n    }\n\n    /**\n     * @dev Derive a symmetric key from a pair of keys using x25519.\n     * @param peerPublicKey The peer's public key.\n     * @param secretKey Your secret key.\n     * @return A derived symmetric key.\n     */\n    function deriveSymmetricKey(\n        Curve25519PublicKey peerPublicKey,\n        Curve25519SecretKey secretKey\n    ) internal view returns (bytes32) {\n        (bool success, bytes memory symmetric) = DERIVE_KEY.staticcall(\n            abi.encode(peerPublicKey, secretKey)\n        );\n        require(success, \"deriveSymmetricKey: failed\");\n        return bytes32(symmetric);\n    }\n\n    /**\n     * @dev Encrypt and authenticate the plaintext and additional data using DeoxysII.\n     * @param key The key to use for encryption.\n     * @param nonce The nonce. Note that only the first 15 bytes of this parameter are used.\n     * @param plaintext The plaintext to encrypt and authenticate.\n     * @param additionalData The additional data to authenticate.\n     * @return The ciphertext with appended auth tag.\n     */\n    function encrypt(\n        bytes32 key,\n        bytes32 nonce,\n        bytes memory plaintext,\n        bytes memory additionalData\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory ciphertext) = ENCRYPT.staticcall(\n            abi.encode(key, nonce, plaintext, additionalData)\n        );\n        require(success, \"encrypt: failed\");\n        return ciphertext;\n    }\n\n    /**\n     * @dev Decrypt and authenticate the ciphertext and additional data using DeoxysII. Reverts if the auth tag is incorrect.\n     * @param key The key to use for decryption.\n     * @param nonce The nonce. Note that only the first 15 bytes of this parameter are used.\n     * @param ciphertext The ciphertext with tag to decrypt and authenticate.\n     * @param additionalData The additional data to authenticate against the ciphertext.\n     * @return The original plaintext.\n     */\n    function decrypt(\n        bytes32 key,\n        bytes32 nonce,\n        bytes memory ciphertext,\n        bytes memory additionalData\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory plaintext) = DECRYPT.staticcall(\n            abi.encode(key, nonce, ciphertext, additionalData)\n        );\n        require(success, \"decrypt: failed\");\n        return plaintext;\n    }\n\n    /**\n     * @dev Generate a public/private key pair using the specified method and seed.\n     * @param alg The signing alg for which to generate a keypair.\n     * @param seed The seed to use for generating the key pair. You can use the `randomBytes` method if you don't already have a seed.\n     * @return publicKey The public half of the keypair.\n     * @return secretKey The secret half of the keypair.\n     */\n    function generateSigningKeyPair(SigningAlg alg, bytes memory seed)\n        internal\n        view\n        returns (bytes memory publicKey, bytes memory secretKey)\n    {\n        (bool success, bytes memory keypair) = GENERAGE_SIGNING_KEYPAIR\n            .staticcall(abi.encode(alg, seed));\n        require(success, \"gen signing keypair: failed\");\n        return abi.decode(keypair, (bytes, bytes));\n    }\n\n    /**\n     * @dev Sign a message within the provided context using the specified algorithm, and return the signature.\n     * @param alg The signing algorithm to use.\n     * @param secretKey The secret key to use for signing. The key must be valid for use with the requested algorithm.\n     * @param digest The hash of the message to sign.\n     * @return signature The resulting signature.\n     */\n    function signDigest(\n        uint256 alg,\n        bytes memory secretKey,\n        bytes memory digest\n    ) internal view returns (bytes memory signature) {\n        (bool success, bytes memory sig) = SIGN_DIGEST.staticcall(\n            abi.encode(alg, secretKey, digest)\n        );\n        require(success, \"signDigest: failed\");\n        return sig;\n    }\n\n    /**\n     * @dev Verifies that the provided digest was signed with using the secret key corresponding to the provided private key and the specified signing algorithm.\n     * @param alg The signing algorithm by which the signature was generated.\n     * @param publicKey The public key against which to check the signature.\n     * @param digest The hash of the message that was signed.\n     * @param signature The signature to check.\n     * @return verified Whether the signature is valid for the given parameters.\n     */\n    function verifyDigestSignature(\n        SigningAlg alg,\n        bytes memory publicKey,\n        bytes memory digest,\n        bytes memory signature\n    ) internal view returns (bool verified) {\n        (bool success, bytes memory v) = VERIFY_DIGEST.staticcall(\n            abi.encode(alg, publicKey, digest, signature)\n        );\n        require(success, \"verifyDigestSignature: failed\");\n        return abi.decode(v, (bool));\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165Checker.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.2) (utils/introspection/ERC165Checker.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Library used to query support of an interface declared via {IERC165}.\n *\n * Note that these functions return the actual result of the query: they do not\n * `revert` if an interface is not supported. It is up to the caller to decide\n * what to do in these cases.\n */\nlibrary ERC165Checker {\n    // As per the EIP-165 spec, no interface should ever match 0xffffffff\n    bytes4 private constant _INTERFACE_ID_INVALID = 0xffffffff;\n\n    /**\n     * @dev Returns true if `account` supports the {IERC165} interface.\n     */\n    function supportsERC165(address account) internal view returns (bool) {\n        // Any contract that implements ERC165 must explicitly indicate support of\n        // InterfaceId_ERC165 and explicitly indicate non-support of InterfaceId_Invalid\n        return\n            supportsERC165InterfaceUnchecked(account, type(IERC165).interfaceId) &&\n            !supportsERC165InterfaceUnchecked(account, _INTERFACE_ID_INVALID);\n    }\n\n    /**\n     * @dev Returns true if `account` supports the interface defined by\n     * `interfaceId`. Support for {IERC165} itself is queried automatically.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(address account, bytes4 interfaceId) internal view returns (bool) {\n        // query support of both ERC165 as per the spec and support of _interfaceId\n        return supportsERC165(account) && supportsERC165InterfaceUnchecked(account, interfaceId);\n    }\n\n    /**\n     * @dev Returns a boolean array where each value corresponds to the\n     * interfaces passed in and whether they're supported or not. This allows\n     * you to batch check interfaces for a contract where your expectation\n     * is that some interfaces may not be supported.\n     *\n     * See {IERC165-supportsInterface}.\n     *\n     * _Available since v3.4._\n     */\n    function getSupportedInterfaces(address account, bytes4[] memory interfaceIds)\n        internal\n        view\n        returns (bool[] memory)\n    {\n        // an array of booleans corresponding to interfaceIds and whether they're supported or not\n        bool[] memory interfaceIdsSupported = new bool[](interfaceIds.length);\n\n        // query support of ERC165 itself\n        if (supportsERC165(account)) {\n            // query support of each interface in interfaceIds\n            for (uint256 i = 0; i < interfaceIds.length; i++) {\n                interfaceIdsSupported[i] = supportsERC165InterfaceUnchecked(account, interfaceIds[i]);\n            }\n        }\n\n        return interfaceIdsSupported;\n    }\n\n    /**\n     * @dev Returns true if `account` supports all the interfaces defined in\n     * `interfaceIds`. Support for {IERC165} itself is queried automatically.\n     *\n     * Batch-querying can lead to gas savings by skipping repeated checks for\n     * {IERC165} support.\n     *\n     * See {IERC165-supportsInterface}.\n     */\n    function supportsAllInterfaces(address account, bytes4[] memory interfaceIds) internal view returns (bool) {\n        // query support of ERC165 itself\n        if (!supportsERC165(account)) {\n            return false;\n        }\n\n        // query support of each interface in interfaceIds\n        for (uint256 i = 0; i < interfaceIds.length; i++) {\n            if (!supportsERC165InterfaceUnchecked(account, interfaceIds[i])) {\n                return false;\n            }\n        }\n\n        // all interfaces supported\n        return true;\n    }\n\n    /**\n     * @notice Query if a contract implements an interface, does not check ERC165 support\n     * @param account The address of the contract to query for support of an interface\n     * @param interfaceId The interface identifier, as specified in ERC-165\n     * @return true if the contract at account indicates support of the interface with\n     * identifier interfaceId, false otherwise\n     * @dev Assumes that account contains a contract that supports ERC165, otherwise\n     * the behavior of this method is undefined. This precondition can be checked\n     * with {supportsERC165}.\n     *\n     * Some precompiled contracts will falsely indicate support for a given interface, so caution\n     * should be exercised when using this function.\n     *\n     * Interface identification is specified in ERC-165.\n     */\n    function supportsERC165InterfaceUnchecked(address account, bytes4 interfaceId) internal view returns (bool) {\n        // prepare call\n        bytes memory encodedParams = abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId);\n\n        // perform static call\n        bool success;\n        uint256 returnSize;\n        uint256 returnValue;\n        assembly {\n            success := staticcall(30000, account, add(encodedParams, 0x20), mload(encodedParams), 0x00, 0x20)\n            returnSize := returndatasize()\n            returnValue := mload(0x00)\n        }\n\n        return success && returnSize >= 0x20 && returnValue > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "contracts/enclave-identity/AttestationToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\ntype TcbId is bytes32;\n\n/// The quote did not link to the registration bundle.\nerror MismatchedRegistration(); // kPomqw== 90fa26ab\n/// The registration has expired.\nerror RegistrationExpired(); // D+WbwA== 0fe59bc0\nerror InvalidQuote(); // +GGAMA== f8618030\n\ncontract AttestationToken is Ownable {\n    struct Quote {\n        bytes32 measurementHash;\n        bytes32 userdata;\n    }\n\n    struct Registration {\n        uint256 baseBlockNumber;\n        bytes32 baseBlockHash;\n        uint256 expiry;\n        address registrant;\n        uint256 tokenExpiry;\n    }\n\n    struct Attestation {\n        uint256 expiry;\n    }\n\n    event Attested(address indexed requester, TcbId indexed tcbId, Quote quote);\n\n    mapping(address => mapping(TcbId => Attestation)) public attestations;\n\n    /// Mock attestation component.\n    address private trustedSender;\n\n    constructor(address _trustedSender) {\n        trustedSender = _trustedSender;\n    }\n\n    function attest(bytes calldata _quote, Registration calldata _reg) external returns (TcbId) {\n        Quote memory quote = _parseQuote(_quote);\n        _validateRegistration(quote.userdata, _reg);\n        TcbId tcbId = _getTcbId(quote);\n        attestations[_reg.registrant][tcbId] = Attestation({expiry: _reg.tokenExpiry});\n        emit Attested(_reg.registrant, tcbId, quote);\n        return tcbId;\n    }\n\n    function getTcbId(bytes calldata _quote) external view returns (TcbId) {\n        Quote memory quote = _parseQuote(_quote);\n        return _getTcbId(quote);\n    }\n\n    function isAttested(address _whom, TcbId _tcbId) external view returns (bool) {\n        return attestations[_whom][_tcbId].expiry > block.timestamp;\n    }\n\n    function setTrustedSender(address _whom) external onlyOwner {\n        trustedSender = _whom;\n    }\n\n    function _getTcbId(Quote memory quote) internal view returns (TcbId) {\n        return TcbId.wrap(keccak256(abi.encode(quote.measurementHash, \"mock tcb\", block.chainid)));\n    }\n\n    function _parseQuote(bytes calldata _quote) internal view returns (Quote memory quote) {\n        quote = abi.decode(_quote, (Quote));\n        if (msg.sender != trustedSender) revert InvalidQuote(); // mock verification\n    }\n\n    function _validateRegistration(\n        bytes32 _expectedHash,\n        Registration calldata _reg\n    ) internal view {\n        if (keccak256(abi.encode(_reg)) != _expectedHash) revert MismatchedRegistration();\n        if (blockhash(_reg.baseBlockNumber) != _reg.baseBlockHash || block.timestamp >= _reg.expiry)\n            revert RegistrationExpired();\n    }\n}\n"
    },
    "contracts/enclave-identity/Lockbox.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Sapphire} from \"@oasisprotocol/sapphire-contracts/contracts/Sapphire.sol\";\n\nimport {AttestationToken, TcbId} from \"./AttestationToken.sol\";\n\ncontract Lockbox {\n    error NoAttestationToken(); // zUKkBQ== cd42a405\n\n    AttestationToken public immutable attestationToken;\n\n    mapping(TcbId => bytes32) private lockbox;\n\n    modifier onlyAttested(TcbId _tcbId) {\n        if (!attestationToken.isAttested(msg.sender, _tcbId)) revert NoAttestationToken();\n        _;\n    }\n\n    constructor(AttestationToken _attestationToken) {\n        attestationToken = _attestationToken;\n    }\n\n    function createKey(TcbId tcbId, bytes calldata pers) external {\n        if (lockbox[tcbId] != 0) return;\n        lockbox[tcbId] = block.chainid == 0x5aff || block.chainid == 0x5afe\n            ? bytes32(Sapphire.randomBytes(32, pers))\n            : blockhash(block.number);\n    }\n\n    function getKey(TcbId tcbId) external view onlyAttested(tcbId) returns (bytes32) {\n        return lockbox[tcbId];\n    }\n}\n"
    },
    "contracts/tasks/acceptor/DelegatedTaskAcceptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {TaskAcceptorV1Proxy} from \"../widgets/TaskAcceptorProxy.sol\";\nimport {TaskAcceptorV1} from \"./TaskAcceptor.sol\";\n\nabstract contract DelegatedTaskAcceptorV1 is TaskAcceptorV1, TaskAcceptorV1Proxy {\n    constructor(address _upstream) TaskAcceptorV1Proxy(_upstream) {\n        return;\n    }\n\n    function _acceptTaskResults(\n        uint256[] calldata,\n        bytes calldata,\n        bytes calldata,\n        address\n    ) internal virtual override returns (TaskIdSelector memory) {\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory result) = address(taskAcceptor()).delegatecall(msg.data);\n        if (!success) revert(string(result));\n        return abi.decode(result, (TaskIdSelector));\n    }\n}\n"
    },
    "contracts/tasks/acceptor/ITaskAcceptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nerror UnknownQuantifier(); // yrtLPA== cabb4b3c\n\ninterface ITaskAcceptorV1 {\n    struct TaskIdSelector {\n        Quantifier quantifier;\n        /// A sorted list identifying subset of submitted tasks that will interpereted per the quantifier.\n        uint256[] taskIds;\n    }\n\n    enum Quantifier {\n        Unknown,\n        All,\n        None,\n        Some,\n        Excluding\n    }\n\n    /// Accepts one or more elements of a task runner's task results submission, returning the seto tasks that were accepted.\n    /// @param _taskIds a sorted set of taskIds completed in this submission\n    /// @param _proof some proof of having completed the identiied tasks that the acceptor can verify.\n    /// @param _report some data provided by the submitter that the requester may or may not trust\n    function acceptTaskResults(\n        uint256[] calldata _taskIds,\n        bytes calldata _proof,\n        bytes calldata _report\n    ) external returns (TaskIdSelector memory);\n}\n\n/// An extension to `ITaskAcceptorV1` that helps task runners know where to find details about how to complete the task.\ninterface ITaskAcceptanceCriteriaV1 is ITaskAcceptorV1 {\n    /// @return a string that could be a URI or some abi-encoded data\n    function taskAcceptanceCriteria(uint256 _taskId) external view returns (string calldata);\n}\n\nlibrary TaskIdSelectorOps {\n    function countSelected(\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\n        uint256 _totalCount\n    ) internal pure returns (uint256 count) {\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) return _totalCount;\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return 0;\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) return _sel.taskIds.length;\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding)\n            return _totalCount - _sel.taskIds.length;\n        revert UnknownQuantifier();\n    }\n\n    /// @param _set a sorted set of task ids\n    function selected(\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\n        uint256[] memory _set\n    ) internal pure returns (uint256[] memory) {\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) return _set;\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return new uint256[](0);\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) return _sel.taskIds;\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding) {\n            uint256[] memory out = new uint256[](countSelected(_sel, _set.length));\n            uint256 selPtr;\n            uint256 outPtr;\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\n                if (_set[setPtr] == _sel.taskIds[selPtr]) continue;\n                out[outPtr] = _set[setPtr];\n                selPtr++;\n                outPtr++;\n            }\n            return out;\n        }\n        revert UnknownQuantifier();\n    }\n\n    function indices(\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\n        uint256[] memory _set\n    ) internal pure returns (uint256[] memory) {\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.All) {\n            uint256[] memory ixs = new uint256[](_set.length);\n            for (uint256 i; i < ixs.length; ++i) ixs[i] = i;\n            return ixs;\n        }\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.None) return new uint256[](0);\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Some) {\n            uint256[] memory ixs = new uint256[](_sel.taskIds.length);\n            uint256 selPtr;\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\n                if (_set[setPtr] != _sel.taskIds[selPtr]) continue;\n                ixs[selPtr] = setPtr;\n                selPtr++;\n            }\n            return ixs;\n        }\n        if (_sel.quantifier == ITaskAcceptorV1.Quantifier.Excluding) {\n            uint256[] memory ixs = new uint256[](countSelected(_sel, _set.length));\n            uint256 selPtr;\n            for (uint256 setPtr; setPtr < _set.length; ++setPtr) {\n                if (_set[setPtr] == _sel.taskIds[selPtr]) continue;\n                ixs[selPtr] = setPtr;\n                selPtr++;\n            }\n            return ixs;\n        }\n        revert UnknownQuantifier();\n    }\n\n    function pick(\n        ITaskAcceptorV1.TaskIdSelector memory _sel,\n        uint256[] memory _set,\n        uint256[] memory _target\n    ) internal pure returns (uint256[] memory) {\n        uint256[] memory ixs = indices(_sel, _set);\n        uint256[] memory placed = new uint256[](ixs.length);\n        for (uint256 i; i < ixs.length; ++i) {\n            placed[i] = _target[ixs[i]];\n        }\n        return placed;\n    }\n\n    function all() internal pure returns (ITaskAcceptorV1.TaskIdSelector memory sel) {\n        sel.quantifier = ITaskAcceptorV1.Quantifier.All;\n    }\n\n    function none() internal pure returns (ITaskAcceptorV1.TaskIdSelector memory sel) {\n        sel.quantifier = ITaskAcceptorV1.Quantifier.None;\n    }\n}\n"
    },
    "contracts/tasks/acceptor/TaskAcceptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ITaskAcceptorV1, TaskIdSelectorOps} from \"./ITaskAcceptor.sol\";\n\n/// The input task ids were not sorted.\nerror SubmisionTaskIdsNotSorted(); // E+1Qrg== 13ed50ae\n/// The set of accepted task ids was not sorted.\nerror AcceptedTaskIdsNotSorted(); // WjXPLQ== 5a35cf2d\n\nabstract contract TaskAcceptorV1 is ITaskAcceptorV1 {\n    using TaskIdSelectorOps for TaskIdSelector;\n\n    function acceptTaskResults(\n        uint256[] calldata _taskIds,\n        bytes calldata _proof,\n        bytes calldata _report\n    ) external virtual returns (TaskIdSelector memory sel) {\n        if (!_isSortedSet(_taskIds)) revert SubmisionTaskIdsNotSorted();\n        _beforeTaskResultsAccepted(_taskIds, _proof, _report, msg.sender);\n        sel = _acceptTaskResults(_taskIds, _proof, _report, msg.sender);\n        if (!_isSortedSet(sel.taskIds)) revert AcceptedTaskIdsNotSorted();\n        _afterTaskResultsAccepted(_taskIds, _report, msg.sender, sel);\n    }\n\n    /// Accepts one or more elements of a task runner's task results submission, returning the seto tasks that were accepted.\n    /// @param _taskIds a sorted set of taskIds completed in this submission\n    /// @param _proof some proof of having completed the identiied tasks that the acceptor can verify.\n    /// @param _report Some data provided by the submitter that the requester may or may not trust\n    /// @param _submitter The account that submitted the task results.\n    /// @return A selection of the accepted task results, which may be empty.\n    function _acceptTaskResults(\n        uint256[] calldata _taskIds,\n        bytes calldata _proof,\n        bytes calldata _report,\n        address _submitter\n    ) internal virtual returns (TaskIdSelector memory);\n\n    /// Runs before tasks are accepted.\n    function _beforeTaskResultsAccepted(\n        uint256[] calldata /* _taskIds */,\n        bytes calldata /* _proof */,\n        bytes calldata /* _report */,\n        address /* _submitter */\n    ) internal virtual {\n        return;\n    }\n\n    function _afterTaskResultsAccepted(\n        uint256[] calldata /* _taskIds */,\n        bytes calldata /* _report */,\n        address /* _submitter */,\n        TaskIdSelector memory /* _selected */\n    ) internal virtual {\n        return;\n    }\n\n    function _isSortedSet(uint256[] memory _input) internal pure returns (bool) {\n        for (uint256 i = 1; i < _input.length; ++i) {\n            if (_input[i] <= _input[i - 1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"
    },
    "contracts/tasks/acceptor/TrustedSenderTaskAcceptor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {Ownable} from \"@openzeppelin/contracts/access/Ownable.sol\";\n\nimport {TaskAcceptorV1} from \"./TaskAcceptor.sol\";\n\nabstract contract TrustedSenderTaskAcceptorV1 is TaskAcceptorV1 {\n    address public immutable trustedSender;\n\n    constructor(address _trustedSender) {\n        trustedSender = _trustedSender;\n    }\n\n    function _acceptTaskResults(\n        uint256[] calldata,\n        bytes calldata,\n        bytes calldata,\n        address _submitter\n    ) internal virtual override returns (TaskIdSelector memory sel) {\n        sel.quantifier = _isTrustedSender(_submitter) ? Quantifier.All : Quantifier.None;\n    }\n\n    function _isTrustedSender(address addr) internal virtual view returns (bool) {\n        return addr == trustedSender;\n    }\n}\n"
    },
    "contracts/tasks/hub/ITaskHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {IERC165} from \"@openzeppelin/contracts/utils/introspection/IERC165.sol\";\n\ninterface ITaskHubV1 is IERC165 {\n    event TasksAvailable(address indexed generator, bytes32 indexed context);\n\n    /// Alerts any listening task runners that there are new tasks available.\n    function notify() external;\n\n    /// Alerts any listening task runners that there are new tasks available.\n    /// @param _context Some indexed data to be emitted with the event for listeners to filter on.\n    function notify(bytes32 _context) external;\n}\n"
    },
    "contracts/tasks/hub/TaskHub.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ERC165} from \"@openzeppelin/contracts/utils/introspection/ERC165.sol\";\n\nimport {ITaskHubV1} from \"./ITaskHub.sol\";\n\n/// @dev The methods in this contract are not marked with `override` are not guaranteed to be in the next version of the contract.\ncontract TaskHubV1 is ITaskHubV1 {\n    function notify() external override {\n        emit TasksAvailable(msg.sender, \"\");\n    }\n\n    function notify(bytes32 _context) external override {\n        emit TasksAvailable(msg.sender, _context);\n    }\n\n    function supportsInterface(bytes4 _interfaceId) public pure override returns (bool) {\n        return _interfaceId == type(ITaskHubV1).interfaceId;\n    }\n}\n"
    },
    "contracts/tasks/widgets/TaskAcceptorProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport {ITaskAcceptorV1} from \"../acceptor/ITaskAcceptor.sol\";\n\nerror NotTaskAcceptor(); // 32ECXQ== df61025d\n\ncontract TaskAcceptorV1Proxy {\n    event TaskAcceptorChanged(address to);\n\n    ITaskAcceptorV1 private taskAcceptor_;\n\n    constructor(address _taskAcceptor) {\n        _setTaskAcceptor(_taskAcceptor);\n    }\n\n    function taskAcceptor() public view virtual returns (ITaskAcceptorV1) {\n        return taskAcceptor_;\n    }\n\n    function _setTaskAcceptor(address _contract) internal {\n        _requireIsTaskAcceptor(_contract);\n        taskAcceptor_ = ITaskAcceptorV1(_contract);\n        emit TaskAcceptorChanged(_contract);\n    }\n\n    function _requireIsTaskAcceptor(address _contract) internal view {\n        if (!_isTaskAcceptor(_contract)) revert NotTaskAcceptor();\n    }\n\n    function _isTaskAcceptor(address _contract) internal view returns (bool) {\n        return !ERC165Checker.supportsInterface(_contract, type(ITaskAcceptorV1).interfaceId);\n    }\n}\n"
    },
    "contracts/tasks/widgets/TaskHubNotifier.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport {ERC165Checker} from \"@openzeppelin/contracts/utils/introspection/ERC165Checker.sol\";\n\nimport {ITaskHubV1} from \"../hub/ITaskHub.sol\";\nimport {TaskHubV1} from \"../hub/TaskHub.sol\";\n\nerror NotTaskHub(); // owTjPw== a304e33f\n\ncontract BaseTaskHubV1Notifier {\n    event TaskHubChanged(address to);\n\n    ITaskHubV1 private taskHub_;\n\n    modifier notify() {\n        _;\n        taskHub_.notify();\n    }\n\n    constructor(address _taskHub) {\n        _setTaskHub(_taskHub);\n    }\n\n    function taskHub() public view virtual returns (ITaskHubV1) {\n        return taskHub_;\n    }\n\n    function _setTaskHub(address _contract) internal {\n        _requireIsTaskHub(_contract);\n        taskHub_ = ITaskHubV1(_contract);\n        emit TaskHubChanged(_contract);\n    }\n\n    function _requireIsTaskHub(address _contract) internal view {\n        if (!_isTaskHub(_contract)) revert NotTaskHub();\n    }\n\n    function _isTaskHub(address _contract) internal view returns (bool) {\n        return !ERC165Checker.supportsInterface(_contract, type(ITaskHubV1).interfaceId);\n    }\n}\n\ncontract TaskHubV1Notifier is BaseTaskHubV1Notifier {\n    constructor() BaseTaskHubV1Notifier(_taskHub()) {\n        return;\n    }\n\n    function _taskHub() private returns (address) {\n        uint256 ch = block.chainid;\n        if (ch == 0x5aff) return 0xAdA897c101918d24d2C424007DdE5AE937DcC02f;\n        if (ch == 1337 || ch == 31337) return address(new TaskHubV1());\n        return address(0);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 4294967295
    },
    "viaIR": true,
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}